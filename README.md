# Pr√°ctica 02.03 ‚Äì L√≥gica con √Årboles Binarios

**Carrera:** Computaci√≥n  
**Asignatura:** Estructura de Datos ‚Äì Segundo Interciclo  
**Estudiante:** Keyra 
**Docente:** Ing. Pablo Torres  
**T√≠tulo:** Estructuras No Lineales ‚Äì Ejercicios con √Årboles Binarios  
**Commit obligatorio:** `"Estructuras No Lineales ‚Äì Ejercicios Arboles"`
# Estructuras No Lineales ‚Äì Ejercicios √Årboles

Este proyecto contiene la soluci√≥n a cuatro ejercicios pr√°cticos sobre estructuras de datos tipo √°rbol binario, como parte del aprendizaje de estructuras no lineales en Java. Cada ejercicio se encuentra organizado en su propia carpeta, siguiendo la convenci√≥n de paquetes y buenas pr√°cticas.

---

## Identificaci√≥n del Estudiante (Obligatorio)

Antes de comenzar a programar o ejecutar el proyecto, **debes completar tu nombre y correo institucional en el archivo `student.env`** que se encuentra en la ra√≠z del proyecto. Este archivo es necesario para validar tu identidad como autor del trabajo.

### ¬øPor qu√© es obligatorio?

Este proyecto utiliza una verificaci√≥n autom√°tica que valida que has ingresado tu informaci√≥n personal. Si no lo haces:

- Al ejecutar el proyecto (`App.java`) ver√°s este mensaje de error:
```
‚ùå Debes completar STUDENT_NAME y STUDENT_EMAIL en student.env
```
- No podr√°s enviar tu c√≥digo (`push`) al repositorio si tienes activado el sistema de validaci√≥n local.
- Las pruebas autom√°ticas en GitHub Actions tambi√©n fallar√°n si no detectan tu nombre y correo.

### ¬øQu√© debo hacer?

1. Abre el archivo `student.env` que ya est√° creado en el proyecto.
2. Rellena tus datos:

```
STUDENT_NAME=Tu Nombre Completo
STUDENT_EMAIL=tu.correo@institucion.edu.ec
```


3. **No borres estas l√≠neas ni cambies los nombres de las variables.**
4. Guarda los cambios y vuelve a ejecutar el programa o hacer push.

> üí° Este mecanismo asegura la autor√≠a del c√≥digo y que cada estudiante reciba su evaluaci√≥n autom√°tica de forma personalizada.

---




## Explicaci√≥n para el estudiante

```
src/
‚îÇ
‚îú‚îÄ‚îÄ Materia/
‚îÇ
‚îú‚îÄ‚îÄ Ejercicio_01_insert/
‚îú‚îÄ‚îÄ Ejercicio_02_invert/
‚îú‚îÄ‚îÄ Ejercicio_03_listLeves/
‚îî‚îÄ‚îÄ Ejercicio_04_depth/
```

---

## Descripci√≥n de Ejercicios

### Ejercicio 01: Insertar en un √Årbol Binario de B√∫squeda (BST)

Carpeta: `Ejercicio_01_insert`
Implementa un algoritmo para insertar nodos en un √Årbol Binario de B√∫squeda.


 **Input de ejemplo:** `[5, 3, 7, 2, 4, 6, 8]`
 **Output esperado:**

```
    5
  3   7
 2 4 6 8
```

---

### Ejercicio 02: Invertir un √Årbol Binario

üìÇ Carpeta: `Ejercicio_02_invert`
Dada la ra√≠z de un √°rbol binario, el algoritmo devuelve su versi√≥n invertida (espejo).

 **Input de ejemplo:**

```
    4
  2   7
1  3 6  9
```

**Output esperado:**

```
    4
  7   2
9  6 3  1
```

---

### Ejercicio 03: Listar Niveles en Listas Enlazadas

üìÇ Carpeta: `Ejercicio_03_listLeves`
Devuelve una lista enlazada con los nodos por nivel. Si hay N niveles, se obtienen N listas.

 **Input de ejemplo:**

```
    4
  2   7
1  3 6  9
```

**Output esperado:**

```
4  
2 ‚Üí 7  
1 ‚Üí 3 ‚Üí 6 ‚Üí 9
```

---

### Ejercicio 04: Calcular la Profundidad M√°xima

Carpeta: `Ejercicio_04_depth`
Calcula la profundidad m√°xima de un √°rbol binario (la longitud del camino m√°s largo desde la ra√≠z hasta una hoja).

**Input de ejemplo:**

```
    4
  2   7
1  3  
8
```

**Output esperado:** `4`

---
## Informe

### Explicaci√≥n del Ejercicio 01 ‚Äì Insertar en un √Årbol Binario de B√∫squeda (BST)
üìå Objetivo del ejercicio:
Implementar un algoritmo que permita insertar valores en un √Årbol Binario de B√∫squeda (BST), manteniendo las propiedades propias de esta estructura.

‚öôÔ∏è Descripci√≥n de la soluci√≥n implementada
El ejercicio est√° contenido en la carpeta Ejercicio_01_insert, e incluye dos clases:

Node.java: Define la estructura del nodo del √°rbol con tres atributos: int value, Node left y Node right.

InsertarBST.java: Contiene la l√≥gica para insertar elementos en el √°rbol y recorrerlo en orden.

üß™ L√≥gica del m√©todo insertar(int valor)
Se usa un m√©todo recursivo llamado insertarRecursivo(Node actual, int valor) que funciona as√≠:

Si el nodo actual es null, se crea un nuevo nodo con el valor dado.

Si el valor es menor que el del nodo actual, se recorre el sub√°rbol izquierdo.

Si el valor es mayor, se recorre el sub√°rbol derecho.

Se retorna el nodo actualizado.

### Explicaci√≥n del Ejercicio 02 ‚Äì Invertir un √Årbol Binario
üìå Objetivo del ejercicio:
Implementar un algoritmo que invierta un √°rbol binario, transform√°ndolo en su imagen especular. Es decir, para cada nodo se deben intercambiar sus hijos izquierdo y derecho de forma recursiva.
‚öôÔ∏è Descripci√≥n de la soluci√≥n implementada
Este ejercicio est√° en la carpeta Ejercicio_02_invert e incluye dos clases:

Node.java: Define los nodos del √°rbol (atributos: value, left, right).

InvertBinaryTree.java: Contiene la l√≥gica para insertar nodos, invertir el √°rbol y recorrerlo.

üîÅ L√≥gica del m√©todo invertTree(Node root)
El m√©todo funciona de manera recursiva:

Si el nodo actual es null, retorna null.

Guarda el hijo izquierdo en una variable temporal.

Invierte recursivamente el sub√°rbol derecho y lo asigna al hijo izquierdo.

Invierte recursivamente el sub√°rbol izquierdo original (guardado en temp) y lo asigna al hijo derecho.

Retorna el nodo actual con sus hijos ya invertidos.

### Explicaci√≥n del Ejercicio 03 ‚Äì Listar niveles en listas enlazadas

üìå Objetivo del ejercicio:
Implementar un algoritmo que recorra un √°rbol binario nivel por nivel (recorrido en anchura o BFS) y almacene los nodos de cada nivel en una lista enlazada o colecci√≥n separada. Si el √°rbol tiene N niveles, el resultado debe ser una lista con N sublistas.

‚öôÔ∏è Descripci√≥n de la soluci√≥n implementada
El ejercicio est√° contenido en la carpeta Ejercicio_03_listLeves y contiene:

Node.java: Define la estructura b√°sica de los nodos (value, left, right).

ListarNiveles.java: Implementa el m√©todo para listar niveles y funciones de inserci√≥n e impresi√≥n.

üîÅ L√≥gica del m√©todo listLevels(Node root)
Se verifica si el √°rbol est√° vac√≠o. Si lo est√°, se retorna una lista vac√≠a.

Se inicializa una cola (Queue<Node>) y se a√±ade la ra√≠z.

Mientras la cola no est√© vac√≠a:

Se obtiene el n√∫mero de nodos en el nivel actual (nivelSize).

Se recorre ese nivel, sacando los nodos de la cola y agreg√°ndolos a una lista temporal.

Se agregan los hijos izquierdo y derecho de cada nodo a la cola.

üéØ Conclusi√≥n del ejercicio:
Se aplic√≥ un recorrido BFS usando una cola para listar niveles del √°rbol binario.

Se implement√≥ una estructura de salida compuesta (List<List<Node>>) que refleja la organizaci√≥n por niveles.

Este ejercicio refuerza el uso de estructuras auxiliares, l√≥gica iterativa y modelado de estructuras complejas.

Es especialmente √∫til para algoritmos relacionados con √°rboles de decisi√≥n, redes y √°rboles de sintaxis.

### Explicaci√≥n del Ejercicio 04 ‚Äì Calcular la Profundidad M√°xima
üìå Objetivo del ejercicio:
Desarrollar un algoritmo que calcule la profundidad m√°xima (tambi√©n llamada altura) de un √°rbol binario, es decir, la cantidad de niveles desde la ra√≠z hasta la hoja m√°s lejana.

üß† ¬øQu√© es la profundidad m√°xima?
La profundidad m√°xima de un √°rbol binario es el camino m√°s largo desde la ra√≠z hasta cualquier hoja. Se mide por la cantidad de nodos que se atraviesan en el camino m√°s profundo.

‚öôÔ∏è Descripci√≥n de la soluci√≥n implementada
El ejercicio se encuentra en la carpeta Ejercicio_04_depth y contiene:

Node.java: Define la estructura b√°sica del nodo del √°rbol (value, left, right).

CalcularProfundidad.java: Implementa el m√©todo maxDepth(Node root) y la l√≥gica para construir y probar el √°rbol.

üîÅ L√≥gica del m√©todo maxDepth(Node root)
Este m√©todo se implementa de forma recursiva, comparando la profundidad de cada sub√°rbol:

Si el nodo actual es null, se retorna 0.

Se calcula la profundidad m√°xima del sub√°rbol izquierdo.

Se calcula la profundidad m√°xima del sub√°rbol derecho.

Se retorna el mayor de los dos valores anteriores + 1 (por el nodo actual).

üéØ Conclusi√≥n del ejercicio:
Se implement√≥ un algoritmo recursivo eficiente para calcular la profundidad de un √°rbol binario.

Se construy√≥ un √°rbol de prueba y se verific√≥ correctamente el valor de la profundidad.

Este tipo de c√°lculo es fundamental en muchos algoritmos que trabajan con √°rboles (balanceo, evaluaci√≥n, an√°lisis de rendimiento).

Se reforzaron conceptos clave como recursi√≥n, subproblemas y comparaci√≥n entre ramas de una estructura.


## Indicaciones Generales

* Lee cuidadosamente el enunciado de cada ejercicio.
* Cada carpeta debe contener:

  * C√≥digo fuente Java.
  * Casos de prueba.
  * Comentarios claros.
* Realiza commit y push con el mensaje:

  ```
  Estructuras No Lineales ‚Äì Ejercicios √Årboles
  ```
* En el AVAC, sube la **URL del repositorio** con el c√≥digo.

---

## No se calificar√° si:

* No hay commit con los ejercicios.
* No se incluye este README explicativo.
* Las clases o m√©todos no siguen los nombres requeridos.

---

## R√∫brica de Calificaci√≥n

| **Criterio**       | **Descripci√≥n**                                                                       | **Puntaje** |
| ------------------ | ------------------------------------------------------------------------------------- | ----------- |
| **Informe**        | No hay informe                                                                        | 0 pts       |
|                    | Informe parcial **sin explicaci√≥n** de cada m√©todo                                    | 1 pt        |
|                    | Informe parcial **con explicaci√≥n** de cada m√©todo                                    | 2 pts       |
|                    | Informe completo                                                                      | 3 pts       |
| **Funcionamiento** | No implementado                                                                       | 0 pts       |
|                    | Implementado parcialmente: <br>‚Ä¢ Ejercicio 1 y 4 ‚Üí 2 pts<br>‚Ä¢ Ejercicio 2 y 3 ‚Üí 4 pts | 2‚Äì4 pts     |
|                    | C√≥digo funcional pero **no pasa todas las pruebas**                                   | 6 pts       |
|                    | C√≥digo funcional y **pasa todas las pruebas correctamente**                           | 7 pts       |



## Contribuir

Para contribuir a este proyecto, por favor crea un fork y env√≠a una solicitud de extracci√≥n, o simplemente abre un issue con tus comentarios y sugerencias.

## Autores

- [PABLO TORRES] - Desarrollo inicial

